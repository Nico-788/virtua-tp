<#
============================================
Integrantes del grupo:
- [Nombre 1]
- [Nombre 2]
- [Nombre 3]
============================================
.SYNOPSIS
    Buscador de informaciÃ³n de paÃ­ses
.PARAMETER Nombre
    PaÃ­ses a buscar
.PARAMETER TTL
    TTL en segundos
#>
param(
    [Parameter(Mandatory=$true)]  #aca fuerzo a que me pasen data
    [ValidateNotNullOrEmpty()] #valido que no este vacio
    [string]$Nombre,
    [Parameter(Mandatory=$false)]
    [ValidateScript({$_ -ge 0})]
    [int]$TTL = 3600
)

$BaseURL = "https://restcountries.com/v3.1/name/" #URL base de la API
$TempPath = [System.IO.Path]::GetTempPath() #Directorio temporal del sistema
$CacheDirectory = Join-Path $TempPath "paises_cache" #Carpeta para guardar el cache de c/u pais

if (-not (Test-Path $CacheDirectory)) {
    New-Item -ItemType Directory -Path $CacheDirectory -Force | Out-Null #Crear carpeta si no existe, el out-null es para que no muestre nada
}                                                           #out-null es como un /dev/null en bash

function Get-NormalizedFilename {
    param([string]$CountryName)
    return $CountryName.ToLower() -replace ' ', '_' -replace '[^a-z0-9_]', '' #Normaliza el nombre del pais para usarlo como nombre de archivo
}  #donde hay espacio pone _ y elimina caracteres especiales

#El try es para intentar crear el archivo y sacar el tiempo, en caso de error, devuelve false 
function Test-CacheValidity { #aca verifica si el cache es valido, osea si existe y si no es mas viejo que el TTL
    param([string]$CacheFilePath)
    if (-not (Test-Path $CacheFilePath)) { return $false } #si no existe el archivo, devuelve falso
    try {   #si existe, obtiene la info del archivo y calcula su antiguedad
        $fileInfo = Get-Item $CacheFilePath
        $age = (Get-Date) - $fileInfo.LastWriteTime
        return $age.TotalSeconds -le $TTL  #puede fallar si esta bloqueado el archivo por otro proceso o si no tenemos los permisos
    } catch { return $false }
}

function Get-CountryFromCache {
    param([string]$CountryName)
    $normalizedName = Get-NormalizedFilename $CountryName #normaliza el nombre del pais, y busca el archivo en la carpeta de cache
    $cacheFile = Join-Path $CacheDirectory "$normalizedName.json" #Join path hace/construye la ruta completa del archivo combinando carpeta y nombre
    
    if (Test-CacheValidity $cacheFile) { #si hay archivo cache y es valido, carga los datos del archivo en varibales y los muestra
        try { #intenta leer el archivo y convertirlo de json a objeto, carga los datos en variables y los muestra
            Write-Host "`nObteniendo de cache: $CountryName" -ForegroundColor Green
            $data = Get-Content $cacheFile -Raw | ConvertFrom-Json
            Write-Host "Pais: $($data.Pais)"
            Write-Host "Capital: $($data.Capital)"
            Write-Host "Region: $($data.Region)"
            Write-Host "Poblacion: $($data.Poblacion)"
            Write-Host "Moneda: $($data.Moneda)`n"
            return $true
        } catch {
            Remove-Item $cacheFile -Force -ErrorAction SilentlyContinue #si hay un error al leer el archivo, lo borra
            return $false
        }
    } else {
        if (Test-Path $cacheFile) { #aca pregunta si el archivo existe pero no es valido, lo borra 
            Remove-Item $cacheFile -Force -ErrorAction SilentlyContinue
        }
        return $false
    }
}
#esta función es la que hace la consulta a la API
function Get-CountryFromAPI {
    param([string]$CountryName) #recibe el nombre del pais que pasamos por parámetro
    Write-Host "`nConsultando API: $CountryName" -ForegroundColor Cyan
    try {
        $encoded = [System.Web.HttpUtility]::UrlEncode($CountryName) #le da formato al pais para que pueda ser parte de una URL, si es español lo vuelve Espa%C3%B1ol
        $url = $BaseURL + $encoded #genera la URL completa para hacer la petición
        $response = Invoke-RestMethod -Uri $url -Method Get -ErrorAction Stop #Invoke hace la petición get a la URL, y si hay error, lo maneja el catch
         #si la respuesta es un array y tiene al menos un elemento, toma el primero (   el que coincide mejor) y extrae los datos
        if ($response -is [Array] -and $response.Count -gt 0) { #si la rta es un arreglo y tiene al menos un elemento, toma el primero
            $country = $response[0] #Country es un vector asociativo, donde cada campo es un elemento del vector
             #extrae los datos del pais, y si no existen, pone "N/A"    
            $data = @{
                Pais = $country.name.common
                Capital = if ($country.capital) { $country.capital[0] } else { "N/A" }
                Region = if ($country.region) { $country.region } else { "N/A" }
                Poblacion = if ($country.population) { $country.population } else { "N/A" }
                Moneda = if ($country.currencies) {
                    $code = $country.currencies.PSObject.Properties.Name | Select-Object -First 1
                    "$($country.currencies.$code.name) ($code)"
                } else { "N/A" }
            }
            
            if ($TTL -gt 0) { #si el TTL es mayor a 0, guarda los datos en el archivo de cache
                $norm = Get-NormalizedFilename $CountryName
                $cache = Join-Path $CacheDirectory "$norm.json"
                $data | ConvertTo-Json | Out-File $cache -Encoding UTF8
            }
            
            Write-Host "Pais: $($data.Pais)"
            Write-Host "Capital: $($data.Capital)"
            Write-Host "Region: $($data.Region)"
            Write-Host "Poblacion: $($data.Poblacion)"
            Write-Host "Moneda: $($data.Moneda)`n"
            return $true
        } else {
            Write-Host "Pais no encontrado: $CountryName" -ForegroundColor Red
            return $false
        }
    } catch {
        Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
        return $false
    }
}

#esta función borra los archivos de cache que ya expiraron según  el TTL, SOLO BORRA
function Remove-ExpiredCache {
    if (Test-Path $CacheDirectory) {
        Get-ChildItem $CacheDirectory -Filter "*.json" | ForEach-Object {
            if (-not (Test-CacheValidity $_.FullName)) {
                Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
            }
        }
    }
}

try {
    Add-Type -AssemblyName System.Web #para usar HttpUtility, que sirve para codificar URLs
    Remove-ExpiredCache #limpia el cache al inicio
     #separa los paises por comas, elimina espacios y filtra los vacios
    
    $countries = $Nombre -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ } #esta filta por cada nombre de pais que le pasamos
    
    if ($countries.Count -eq 0) { #si no hay paises validos, muestra error y sale
        Write-Host "Error: No se especificaron paises validos" -ForegroundColor Red
        exit 1
    }
    
    Write-Host "Buscando $($countries.Count) pais(es)..." -ForegroundColor Green
    Write-Host "TTL: $TTL segundos`n" -ForegroundColor Green
    
    $errores = 0
    foreach ($country in $countries) {
        if (-not (Get-CountryFromCache $country)) { #primero intenta obtener del cache, si no puede, va a la API
            if (-not (Get-CountryFromAPI $country)) { $errores++ }
        }
    }
    
    if ($errores -gt 0) {
        Write-Host "Completado con $errores error(es)" -ForegroundColor Yellow
        exit 1
    }
    
    Write-Host "Busqueda completada" -ForegroundColor Green
    exit 0
} catch { #aca sino puede cargar System.Web o hay otro error inesperado, muestra el error y sale
    Write-Host "Error inesperado: $($_.Exception.Message)" -ForegroundColor Red 
    exit 1
} finally {
    Remove-ExpiredCache #limpia el cache al final por si se demoró mucho y algun archivo venció mientras corría el script
}
